:imgbase: ../images/
:empty-string:

ifdef::site-gen-antora[]
:imgbase: {empty-string}
endif::[]

= Architecture
ifndef::site-gen-antora[]
:toc:
endif::[]

== Introduction

=== Decentralized Insurance Protocol (DIP)

The Decentralized Insurance Protocol (DIP) enables the creation and management of decentralized insurance products. The protocol is designed to be flexible and extensible, allowing for the creation of a wide range of insurance products. 

The protocol supports a multi-chain ecosystem to let users choose the chain that best fits their needs. The protocol is designed to be chain agnostic, allowing for the deployment of the protocol on any EVM compatible chain.

=== Generalized Insurance Framework (GIF)

The Generalized Insurance Framework (GIF) is a set of smart contracts that implement the Decentralized Insurance Protocol (DIP). 
The main Goal of the GIF is to support its users in creating and managing decentralized insurance products as efficitiently and safe as possible. 

GIF users should be able to focus on their use case specific business logic.
GIF takes care of the use case independent heavy lifting like managing policies, claims, payouts, managing collateral in pools, etc.

The GIF itself is a highly modularized and flexible infrastructure that can be deployed to any EVM compatible chain.
Most contracts of the GIF will already be deployed and are ready to be used by the users.

== Multi-Chain Setup

=== Overview

For each supported chain a chain specific GIF setup is deployed.
To link all chains together a global registry is deployed on mainnet.
This global registry then holds the links to all chain specific registries as shown in the diagram below.


image::{imgbase}multi-chain-setup.png[Multi-chain setup]

=== Global Registry

The global registry is deployed on mainnet can be understood as the directory and entry point for the complete protocol ecosystem. 

The global registry contains entries for all protocol relevant objects on mainnet and a chain registry entry for each supported chain in the ecosystem.
At the same time the global registy plays the role of the mainnet chain registry.

=== Chain Registries

On each chain supported by the protocol a chain registry is deployed.
A chain registry contains entries for all protocol relevant objects on that specific chain.
These entries hold basic metadata of the object and are backed by an NFT that defines the ownership of the object.

The list below provides the basic metadata for each object in the registry:

* NFT ID: A protocol unique ID
* Parent NFT ID: A pointer to the parent object in the registry
* Object Type: The type of the object (registry, service, instance, product, policy, etc)
* Object Address: The contract address for contract objects

=== Protocol Objects

The following objects are managed by the protocol:

[cols="1,3"]
|===
|Object |Comments

|Protocol |The object representing the protocol itself
|Registry |Registry contracts
|Instance |Instance contracts linked to the chain registry
|Product |Product contracts linked to an instance
|Policy |Policy object linked to a product contract
|Distribution |Distribution contracts linked to an instance
|Distributor |Distributor object linked to a distribution contract
|Oracle |Oracle contracts linked to an instance
|Pool |Pool contracts linked to an instance
|Bundle |Bundle object linked to a pool contract
|Staking |Staking contracts linked to the chain registry
|Stake |Stake object linked to its target object (instance or protocol)
|===


== Single-Chain Setup

=== Overview

The GIF setup on any specific chain always consists of a registry and staking modules, services and instances as shown in the diagram below.

image::{imgbase}single-chain-setup.png[Single-chain setup]

=== Registry

Registries have already been introduced in the text above.
As already mentioned a registry is the central entry point for all protocol objects on a specific chain.

=== Staking

The staking module is used to manage the DIP that are staked by users to either the protocol itself or to an instance that is registered as a staking target.

=== Instance

Instances are used by ecosystem participants to create and operate actual use cases/products.
Instances consist of a set of instance contracts and a number of so-called components that are required to implement an actual use cases. 

=== Components

Currently, products, distributions, oracles, and pools as supported by GIF as component types.

=== Services

Services are used to implement the generic insurance business logic of the GIF.
Components, instances, the registry and the staking module may only interact with each other through these generic service contracts.

== Modules and Services

=== Overview

=== Modules

Modules are defined as a set of one or more contracts that serve a specific purpose.
Each contract in a module has its clear role and responsibility.
Contracts in the same module may directly interact with each other. 
Module contracts may never directly interact with contracts from other modules.
Instead, a module contract may call a service contract that then interact with a contract in another module on its behalf.

Examples of modules are the registry module, the staking module, instance and component modules.
Except for the staking module, all modules are non-upgradeable.

=== Services

Services have a domain scope such as "Registry" or "Policy" and implement the domain specific business logic.
Services are stateless and only operate on the state of the involved module contracts.
Service contract may also interact with other service contracts.

All service contracts are upgradeable to allow for bug fixing and minor enhancements.
Service contract upgrades are only allowed for non-breaking changes.

=== Registry Module

The registry module diagram below provides an overview of the registry related contracts of a GIF deployment.

image::{imgbase}registry-module.png[Registry Module]

Contracts and their responsibilities are outlined below.

[cols="1,3"]
|===
| Contract | Responsibility

| GIF Admin
(Actor)
| The account with the GIF Admin role initiates and confirms new GIF releases.

| GIF Manager
(Actor)
| An account with a GIF Manager role deploys and registers service contracts of new GIF releases.
Manages token white listing.

| ChainNft
| Mints and manages all NFTs related to the objects stored in the registry.
Only the registry contract may call state changing functions on this contract.

| Registry
| Stores entries for all protocol relevant objects on this chain.

| ReleaseRegistry
| Keeps track of all deployed major releases so far.
Manages deployment of new releases.

| TokenRegistry
| Manages whitelisting of supported ERC20 tokens per major release.

| RegistryAdmin
| Central authorization for all core contracts (resistry module and staking module) and all service contracts from all major releases.

| RegistryService
| A registry service contract from a specific GIF release.
Registry service contracts are authoriezd to register new objects with the registry.

| Other Services
| TODO remove this component also remove dashed line beween registry and registry service.

| Dip
| The DIP token deployed outside of the GIF deployment.
The DIP token is always registered with the Token registry.

|===

=== Staking Module

The staking module diagram below provides an overview of the registry related contracts of a GIF deployment.

image::{imgbase}staking-module.png[Staking Module]

Contracts and their responsibilities are outlined below.

[cols="1,3"]
|===
| Contract | Responsibility

| StakingReader
| Provides all read access functions to staking related data.

| StakingStore
| Stores all staking related data like staked DIPs per staker and target, available staking targets, total locked value per target staked DIPs per target.

| Staking
| The central staking contract that implements to upgradeable business logic for staking.

| StakingService
| A release specific service contract that is authorized to create new stakes and manage existing stakes.

| PoolService
| Informs the staking contract about changes in the total locked value (TVL) amounts of the instances.

| RegistryAdmin
| Central authorization for all core contracts (resistry module and staking module) and all service contracts from all major releases.

|===


=== Instance Module

The instance module diagram below provides an overview of the instance related contracts.

image::{imgbase}instance-module.png[Instance Module]

Contracts and their responsibilities are outlined below.

[cols="1,3"]
|===
| Contract/Account | Responsibility

| Instance Owner
(Actor)
| Contract/Account that is the holder of the instance NFT that represents this particular instance.
The instance NFT is linked to the instance contract and registered in the registry.

| Instance
| Central instance contract that manages instance authorization and references to other instance module contracts.

| InstanceReader
| Provides all read access functions to instance related data.
This includes data access for all components linked to the instance.

| InstanceStore
| Stores all instance related data like managed components, polices, bundles, distributors etc.

| BundleSet
| Manages the set of active policies for each bundle.

| RiskSet
| Manages the set of active policies for each risk.

| InstanceAdmin
| Central authorization for all instance and linked component contracts as well as all service contracts that need write access to instance data.

| Services ...
| The set of services that interact with the instance module.

|===


=== Component Modules

Component modules are are always linked to a specific instance module.
The term "component module" covers four distinct types of components that together implement the actual use case specific business logic of a concrete use case.

The diagram below shows the architecture of an exemplary "My Product" use case.

image::{imgbase}component-modules.png[Component Modules]

Moudle contracts and their responsibilities are outlined below.

[cols="1,3"]
|===
| Contract/Account | Responsibility

| Product Owner
(Actor)
| Contract/Account that is the holder of the product NFT that represents this particular product.
The NFT is linked to the product contract and registered in the registry.

| Distribution Owner
(Actor)
| Contract/Account that is the holder of the distribution NFT that represents this particular distribution contract.
The NFT is linked to the distribution contract and registered in the registry.

| Oracle Owner
(Actor)
| Contract/Account that is the holder of the oracle NFT that represents this particular oracle contract.
The NFT is linked to the oracle contract and registered in the registry.

| Pool Owner
(Actor)
| Contract/Account that is the holder of the pool NFT that represents this particular pool contract.
The NFT is linked to the pool contract and registered in the registry.

| My Product
| Does not contain actual contracts, It represents the use case specific collection of component moudules that are required to implement and operate the use case.

| Product Module
| The use case specific product contract that manages policies, claims and payouts.
The product contract is based on product template contract provided by the framework.
The module may includes additional supporting contracts.
A Pool module always needs to be linked to a pool module.
Links to a distribution module and oracle modules are optional

| Distribution Module
| The use case specific distribution contract that manages distributors, referral codes and policy sales.
The distribution contract is based on distribution template contract provided by the framework.
The module may includes additional supporting contracts.
A distribution module is always linked to a single product module

| Oracle Module
| One or more use case specific oracle modules. 
Each oracle module contains an oracle contract that manages oracle requests and responses that connect the product to real world (off-chain) data.
The oracle contracts are based on a oracle template contract provided by the framework.
The modules may includes additional supporting contracts.
Any oracle module is always linked to a single product module.

| Pool Module
| The use case specific pool contract that manages bundles which in turn provide the risk capital of the use case.
The pool contract is based on pool template contract provided by the framework.
The module may includes additional supporting contracts.
A pool moudle is always linked to a single product module

| Instance Module
| The instance module that links all component modules and also holds the data related to the component modules.
During operation the linked instance module manages the data related to all relevant business objects like policies, claims, payouts, bundles, distributors, etc.

| Registry Module
| When setting up a new use case, component modules are registerd with the instance module and the registry module.
For each registered component module an associated registry entry is created and a component module specific NFT is minted.
Additional registry entries and NFTs are created during the operation of the use case.
In this phase NFTs are also minted for most business relevant objects such as policies or bundles.
|===

== Instances
=== Overview
=== Stakeholders
=== Business Objects
=== Creating a new Instance
=== Registering Components
=== Authorization Management
=== Instance Staking

== Components
=== General Principles
=== Token Management
=== Contracts

The component diagram below provides the overview of the component contract hierarchy.

image::{imgbase}component-diagram.png[Component Diagram]


[cols="1,3"]
|===
| Contract | Responsibility

| `(I)RegistryLinked` +
(shared) 
| Base interface and implementation for contracts that are linked to the registry.
Any contract that needs to query or interact with the registry is derived from this base contract.
This base class is also derived from OpenZeppelin's `Initializable` to support upgradeability and contract cloning.

| `(I)NftOwnable` +
(shared) 
| Base interface and implementation for contracts which define ownability via the owner of the NFT corresponding to a contract registered in the registry. 
The linking to the NFT is done via the `linkToRegisteredNftId` function that looks up the NFT ID in the registry using the contract address.

| `(I)Registerable` +
(shared) 
| Base interface and implementation for contracts that need to be registered with the registry.
Registerable contracts provide all necessary information to be registered via its `getInitialInfo` function.


| `(I)Component` +
(shared) 
| Base interface and implementation for all component contracts.

|===

== Product Components
=== Overview
=== Stakeholders
==== Product Owner
==== Policy Holder
=== Business Objects
==== Risks
==== Applications
==== Policies
==== Claims
==== Payouts
=== Business Processes
==== Pricing
==== Application Creation
==== Policy Collateralization
==== Policy Expiry
==== Policy Closure
==== Claims Creation
==== Payout Handling
=== Contracts

== Distribution Components
=== Overview
=== Stakeholders
==== Distribution Owner
==== Distributors
=== Business Objects
==== Distributor Types
==== Distributors
==== Referral Codes
=== Business Processes
==== Distributor Type Creation
==== Distributor Creation
==== Referral Code Creation
=== Fee and Commissions Management
=== Contracts

== Oracle Components
=== Overview
=== Business Objects
==== Requests
==== Responses
=== Business Processes
==== Request Creation
==== Response Handling
=== Contracts

== Pool Components
=== Overview
=== Stakeholders
==== Pool Owner
==== Bundle Owner
=== Pool Properties
=== Bundles
=== Business Processes
==== Bundle Creation
==== Bundle Locking and Unlocking
==== Bundle Staking and Unstaking
==== Bundle Expiry
=== Fee Management
=== Contracts

== Authorization

=== Overview

Autorization is a key concept in the GIF.
Authorization is organized per supported chain and implemented in access admin contracts using role based access control.
Role based access control involves roles, targets and functions level authorization.

Roles can be considered as lables or IDs that can be assigned (granted) to accounts or removed (revoked) from accounts.
*Accounts* can either be externally owned accounts or contract accounts.
The set of accounts that have a specific role is called the role members.

The term *Targets* is used for contracts for which function level authorization is managed by an access admin contract.
That particular access admin contract is then called the authority of the target contract.

*Function Level Authorization* defines which fuctions of a target may be executed through which role.
For each authorized function of a target the required role to access it is defined.
Only a single role can be specified per function and only members of that role (both contracts and externally owned accounts) may then execute the function.

=== Access Admin

Access admin contracts manage explicit lists of named targets, roles and functions that are granted to these roles.
It also provides view functions that allow to enumerate all available roles, current role members and all granted functions for every managed target.

The implementation of the access admin contract is based on OpenZeppelin's `AccessManagerUpgradeable` and `AccessManagedUpgradeable` contracts.

The access admin contract extends the OpenZeppelin functionality by providing named roles, targets and functions and by providing the capability to enumerate all current role members and all granted functions for every managed target.

The access admin contract is the base contract for two specialized admin contracts.
Per supported chain there is a registry admin contract and for each instance there is an instance admin contract.

=== Registry Admin

The registry admin contract is the central contract that controls access to the registry, to staking as well as interactions between service contracts.

In the case of services the registry admin maintains access to service functions per major release in the sense that a service of a specific major release may only interact with services of the same major release.

=== Instance Admin

For each instance an individual instance admin contract exits.
This instance admin is used to manage authorizations for the interactions between the instance and all its linked components with all linked services.

=== Upgrading Contracts

Authorization for upgrading upgradeable contracts is a special case.
Every upgradeable contract in GIF comes with its own proxy manager contract.
Only this proxy manager contract may be used to upgrade an upgradeable contract.
And only the owner of an upgradeable contract may execute an upgrade via this proxy manager contract.

The ownership of an GIF relevant upgradeable contract is defined via its NFT as recorded in the chain registry.

Upgradeability relies on OpenZeppelin's `TransparentUpgradeableProxy` and `ProxyAdmin` contracts.

== Release Management

=== Overview

GIF releases follow semantic versioning, which includes major, minor, and patch releases. 
The major version number is incremented whenever there are breaking changes that could potentially disrupt existing functionality or compatibility.

For every major releases, a consistent set of upgradeable service contracts are deployed and registered with the registry. 
For non-breaking changes the existing service contracts are upgraded in place.
The staking module is independently upgradeable and may be upgraded at any time.
The registry module is non-upgradeable and is capable of serving multiple major releases simultaneously.
Instance modules are non-upgradeable and directly linked to the service contracts of the same major release.

Adding a new major release is guarded by role based authorization including two roles, a GIF Admin role and the GIF Manager role.

=== Core Deployment

The core deployment sets up the registry and the staking modules and includes all the wiring between the contracts needed for actual relese deployment.
For each supported chain a core deployment is the required first step.

For the registry module deployments the contracts Registry, ChainNft, TokenRegistry, and RegistryAdmin are deployed and initialized.
Where neceesary these contracts are linked to the registry admin contract that manages all authorization for both the registry and the staking module.

On mainnet the *Regsitry* contract is deployed and initialized with two entries, one for the protocol object and one for global registry.
On any other chain the initial setup includes an additional entry for the chain registry.

The registry istelf deployes the *ChainNFT* contract that will hold NFT representations of all protocol relevant objects on this chain.

The *TokenRegistry* is deployed and initialized with the DIP token as staking token.

The *RegistryAdmin* contract is deployed intialized with the GIF Admin role and the GIF Manager role.

* The necessary authorizations are put in place to allow the GIF Admin and GIF Manager roles to deploy the first major release.
* For the whitelisting of tokens the GIF Manager role is granted the necessary authorizations.
* For release deployment the release registry contract is authorized to register new service contracts with the registry.
* Regstry services (for all releases) are granted access to register objects with the registry contract.
* Staking services (for all releases) are granted access to the staking contract.
* Pool services (for all releases) are granted access to the staking contract to update the total value locked in instances.s

For the staking module deployment the contracts StakingReader, StakingStore, StakingManager and Staking are deployed and initialized.
The staking contract is also registerd with the registry.

=== Release Deployment

The release deployment is the second and final GIF deployment step to a specific chain.
For each supported chain a release deployment is required.
A release deployment to a new chain will only include the deployment of the latest major release.
Initially this will be the GIF v3 release.
In the future new major releases should be deployed on all chains that are actively supported by the protocol.

A release deployment consist of the deployment and authorization of a release specific and consistent set of service contracts.
As the service authorization is restricted to other services of the same release, services are assigned release specific roles.
Service authorization is managed by the registry admin contract and defines which service fuction may be called by which other service.

The process of a release deployment invlovles the GIF Admin and the GIF Manager roles.
The GIF Admin role represents the principal owner of the protocol and GIF Manager role is the role that is authorized to deploy and register the service contracts with the release registry.

[cols="1,2,2,4"]
|===
| Step | Role | Action | Comment

| 1
| GIF Admin
| `createNextRelease`
| Initiates the deployment of the next major relase, sets the release registry contract into the state where release deployment is enabled.

| 2
| GIF Manager
| `prepareNextRelease`
| Lets the release manager provide the authorization specification for the new release. 
This includes the ordered list of service domains relevant to the release.

| 3
| GIF Manager
| `registerService` +
n times, once for each service contract.
| The deployed release service contracts are registered with the release registry in the same order as defined in the authorization specification.

| 4
| GIF Admin
| `activateNextRelease`
| After verifying the release deployment the GIF Admin can activate the new release.
|===
