:github-icon: pass:[<svg class="icon"><use href="#github-icon"/></svg>]
:xref-NftOwnable-onlyOwner--: xref:shared.adoc#NftOwnable-onlyOwner--
:xref-NftOwnable-onlyNftOwner-NftId-: xref:shared.adoc#NftOwnable-onlyNftOwner-NftId-
:xref-NftOwnable-onlyNftOfType-NftId-ObjectType-: xref:shared.adoc#NftOwnable-onlyNftOfType-NftId-ObjectType-
:xref-TokenHandler-onlyService--: xref:shared.adoc#TokenHandler-onlyService--
= Shared

Contains interfaces and contracts used across the project.

== Contracts

:ErrorNftOwnableInitialOwnerZero: pass:normal[xref:#INftOwnable-ErrorNftOwnableInitialOwnerZero--[`++ErrorNftOwnableInitialOwnerZero++`]]
:ErrorNftOwnableNotOwner: pass:normal[xref:#INftOwnable-ErrorNftOwnableNotOwner-address-[`++ErrorNftOwnableNotOwner++`]]
:ErrorNftOwnableInvalidType: pass:normal[xref:#INftOwnable-ErrorNftOwnableInvalidType-NftId-ObjectType-[`++ErrorNftOwnableInvalidType++`]]
:ErrorNftOwnableAlreadyLinked: pass:normal[xref:#INftOwnable-ErrorNftOwnableAlreadyLinked-NftId-[`++ErrorNftOwnableAlreadyLinked++`]]
:ErrorNftOwnableContractNotRegistered: pass:normal[xref:#INftOwnable-ErrorNftOwnableContractNotRegistered-address-[`++ErrorNftOwnableContractNotRegistered++`]]
:linkToRegisteredNftId: pass:normal[xref:#INftOwnable-linkToRegisteredNftId--[`++linkToRegisteredNftId++`]]
:getNftId: pass:normal[xref:#INftOwnable-getNftId--[`++getNftId++`]]
:getOwner: pass:normal[xref:#INftOwnable-getOwner--[`++getOwner++`]]

[.contract]
[[INftOwnable]]
=== `++INftOwnable++` link:https://github.com/etherisc/gif-next/blob/develop/contracts/shared/INftOwnable.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@etherisc/gif-next/contracts/shared/INftOwnable.sol";
```

[.contract-index]
.Functions
--
* [`++linkToRegisteredNftId()++`]
* [`++getNftId()++`]
* [`++getOwner()++`]

[.contract-subindex-inherited]
.IRegistryLinked
* [`++getRegistry()++`]

[.contract-subindex-inherited]
.IERC165
* [`++supportsInterface(interfaceId)++`]

--

[.contract-item]
[[INftOwnable-linkToRegisteredNftId--]]
==== `[.contract-item-name]#++linkToRegisteredNftId++#++() → NftId++` [.item-kind]#external#

[.contract-item]
[[INftOwnable-getNftId--]]
==== `[.contract-item-name]#++getNftId++#++() → NftId++` [.item-kind]#external#

[.contract-item]
[[INftOwnable-getOwner--]]
==== `[.contract-item-name]#++getOwner++#++() → address++` [.item-kind]#external#

:policyActivated: pass:normal[xref:#IPolicyHolder-policyActivated-NftId-Timestamp-[`++policyActivated++`]]
:policyExpired: pass:normal[xref:#IPolicyHolder-policyExpired-NftId-Timestamp-[`++policyExpired++`]]
:claimConfirmed: pass:normal[xref:#IPolicyHolder-claimConfirmed-NftId-ClaimId-Amount-[`++claimConfirmed++`]]
:payoutExecuted: pass:normal[xref:#IPolicyHolder-payoutExecuted-NftId-PayoutId-Amount-address-[`++payoutExecuted++`]]

[.contract]
[[IPolicyHolder]]
=== `++IPolicyHolder++` link:https://github.com/etherisc/gif-next/blob/develop/contracts/shared/IPolicyHolder.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@etherisc/gif-next/contracts/shared/IPolicyHolder.sol";
```

Generic interface for contracts that need to hold policies and receive payouts.
The framework notifies policy holder contracts for policy creation/expiry, claim confirmation and payout execution

[.contract-index]
.Functions
--
* [`++policyActivated(policyNftId, activatedAt)++`]
* [`++policyExpired(policyNftId, expiredAt)++`]
* [`++claimConfirmed(policyNftId, claimId, amount)++`]
* [`++payoutExecuted(policyNftId, payoutId, amount, beneficiary)++`]

[.contract-subindex-inherited]
.IRegistryLinked
* [`++getRegistry()++`]

[.contract-subindex-inherited]
.IERC721Receiver
* [`++onERC721Received(operator, from, tokenId, data)++`]

[.contract-subindex-inherited]
.IERC165
* [`++supportsInterface(interfaceId)++`]

--

[.contract-item]
[[IPolicyHolder-policyActivated-NftId-Timestamp-]]
==== `[.contract-item-name]#++policyActivated++#++(NftId policyNftId, Timestamp activatedAt)++` [.item-kind]#external#

Callback function that will be called after successful policy activation.
Active policies may open claims under the activated policy.

[.contract-item]
[[IPolicyHolder-policyExpired-NftId-Timestamp-]]
==== `[.contract-item-name]#++policyExpired++#++(NftId policyNftId, Timestamp expiredAt)++` [.item-kind]#external#

Callback function to indicate the specified policy has expired.
expired policies no longer accept new claims.

[.contract-item]
[[IPolicyHolder-claimConfirmed-NftId-ClaimId-Amount-]]
==== `[.contract-item-name]#++claimConfirmed++#++(NftId policyNftId, ClaimId claimId, Amount amount)++` [.item-kind]#external#

Callback function to notify the confirmation of the specified claim.

[.contract-item]
[[IPolicyHolder-payoutExecuted-NftId-PayoutId-Amount-address-]]
==== `[.contract-item-name]#++payoutExecuted++#++(NftId policyNftId, PayoutId payoutId, Amount amount, address beneficiary)++` [.item-kind]#external#

Callback function to notify the successful payout.

:getRelease: pass:normal[xref:#IRegisterable-getRelease--[`++getRelease++`]]
:getInitialInfo: pass:normal[xref:#IRegisterable-getInitialInfo--[`++getInitialInfo++`]]

[.contract]
[[IRegisterable]]
=== `++IRegisterable++` link:https://github.com/etherisc/gif-next/blob/develop/contracts/shared/IRegisterable.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@etherisc/gif-next/contracts/shared/IRegisterable.sol";
```

Marks contracts that are intended to be registered in the registry.

[.contract-index]
.Functions
--
* [`++getRelease()++`]
* [`++getInitialInfo()++`]

[.contract-subindex-inherited]
.INftOwnable
* [`++linkToRegisteredNftId()++`]
* [`++getNftId()++`]
* [`++getOwner()++`]

[.contract-subindex-inherited]
.IRegistryLinked
* [`++getRegistry()++`]

[.contract-subindex-inherited]
.IERC165
* [`++supportsInterface(interfaceId)++`]

--

[.contract-item]
[[IRegisterable-getRelease--]]
==== `[.contract-item-name]#++getRelease++#++() → VersionPart release++` [.item-kind]#external#

retuns the GIF release version for this contract.
This

[.contract-item]
[[IRegisterable-getInitialInfo--]]
==== `[.contract-item-name]#++getInitialInfo++#++() → struct IRegistry.ObjectInfo++` [.item-kind]#external#

retuns the object info relevant for registering for this contract 
IMPORTANT information returned by this function may only be used
before the contract is registered in the registry.
Once registered this information MUST only be accessed via the registry.

:ErrorNotRegistry: pass:normal[xref:#IRegistryLinked-ErrorNotRegistry-address-[`++ErrorNotRegistry++`]]
:getRegistry: pass:normal[xref:#IRegistryLinked-getRegistry--[`++getRegistry++`]]

[.contract]
[[IRegistryLinked]]
=== `++IRegistryLinked++` link:https://github.com/etherisc/gif-next/blob/develop/contracts/shared/IRegistryLinked.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@etherisc/gif-next/contracts/shared/IRegistryLinked.sol";
```

[.contract-index]
.Functions
--
* [`++getRegistry()++`]

--

[.contract-item]
[[IRegistryLinked-getRegistry--]]
==== `[.contract-item-name]#++getRegistry++#++() → contract IRegistry++` [.item-kind]#external#

:ErrorServiceNotImplemented: pass:normal[xref:#IService-ErrorServiceNotImplemented--[`++ErrorServiceNotImplemented++`]]
:getDomain: pass:normal[xref:#IService-getDomain--[`++getDomain++`]]
:getRoleId: pass:normal[xref:#IService-getRoleId--[`++getRoleId++`]]

[.contract]
[[IService]]
=== `++IService++` link:https://github.com/etherisc/gif-next/blob/develop/contracts/shared/IService.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@etherisc/gif-next/contracts/shared/IService.sol";
```

[.contract-index]
.Functions
--
* [`++getDomain()++`]
* [`++getRoleId()++`]

[.contract-subindex-inherited]
.IRegisterable
* [`++getRelease()++`]
* [`++getInitialInfo()++`]

[.contract-subindex-inherited]
.INftOwnable
* [`++linkToRegisteredNftId()++`]
* [`++getNftId()++`]
* [`++getOwner()++`]

[.contract-subindex-inherited]
.IRegistryLinked
* [`++getRegistry()++`]

[.contract-subindex-inherited]
.IERC165
* [`++supportsInterface(interfaceId)++`]

[.contract-subindex-inherited]
.IAccessManaged
* [`++authority()++`]
* [`++setAuthority()++`]
* [`++isConsumingScheduledOp()++`]

[.contract-subindex-inherited]
.IVersionable
* [`++initializeVersionable(activatedBy, activationData)++`]
* [`++upgradeVersionable(upgradeData)++`]
* [`++getVersion()++`]

--

[.contract-index]
.Events
--

[.contract-subindex-inherited]
.IRegisterable

[.contract-subindex-inherited]
.INftOwnable

[.contract-subindex-inherited]
.IRegistryLinked

[.contract-subindex-inherited]
.IERC165

[.contract-subindex-inherited]
.IAccessManaged
* [`++AuthorityUpdated(authority)++`]

[.contract-subindex-inherited]
.IVersionable

--

[.contract-item]
[[IService-getDomain--]]
==== `[.contract-item-name]#++getDomain++#++() → ObjectType serviceDomain++` [.item-kind]#external#

returns the domain for this service.
In any GIF release only one service for any given domain may be deployed.

[.contract-item]
[[IService-getRoleId--]]
==== `[.contract-item-name]#++getRoleId++#++() → RoleId serviceRoleId++` [.item-kind]#external#

returns the GIF release specific role id.
These role ids are used to authorize service to service communication.

:NFT_OWNABLE_STORAGE_LOCATION_V1: pass:normal[xref:#NftOwnable-NFT_OWNABLE_STORAGE_LOCATION_V1-bytes32[`++NFT_OWNABLE_STORAGE_LOCATION_V1++`]]
:NftOwnableStorage: pass:normal[xref:#NftOwnable-NftOwnableStorage[`++NftOwnableStorage++`]]
:onlyOwner: pass:normal[xref:#NftOwnable-onlyOwner--[`++onlyOwner++`]]
:onlyNftOwner: pass:normal[xref:#NftOwnable-onlyNftOwner-NftId-[`++onlyNftOwner++`]]
:onlyNftOfType: pass:normal[xref:#NftOwnable-onlyNftOfType-NftId-ObjectType-[`++onlyNftOfType++`]]
:_checkNftType: pass:normal[xref:#NftOwnable-_checkNftType-NftId-ObjectType-[`++_checkNftType++`]]
:_initializeNftOwnable: pass:normal[xref:#NftOwnable-_initializeNftOwnable-address-address-[`++_initializeNftOwnable++`]]
:linkToRegisteredNftId: pass:normal[xref:#NftOwnable-linkToRegisteredNftId--[`++linkToRegisteredNftId++`]]
:getNftId: pass:normal[xref:#NftOwnable-getNftId--[`++getNftId++`]]
:getOwner: pass:normal[xref:#NftOwnable-getOwner--[`++getOwner++`]]
:_linkToNftOwnable: pass:normal[xref:#NftOwnable-_linkToNftOwnable-address-[`++_linkToNftOwnable++`]]

[.contract]
[[NftOwnable]]
=== `++NftOwnable++` link:https://github.com/etherisc/gif-next/blob/develop/contracts/shared/NftOwnable.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@etherisc/gif-next/contracts/shared/NftOwnable.sol";
```

[.contract-index]
.Modifiers
--
* {xref-NftOwnable-onlyOwner--}[`++onlyOwner()++`]
* {xref-NftOwnable-onlyNftOwner-NftId-}[`++onlyNftOwner(nftId)++`]
* {xref-NftOwnable-onlyNftOfType-NftId-ObjectType-}[`++onlyNftOfType(nftId, expectedObjectType)++`]
--

[.contract-index]
.Functions
--
* [`++_checkNftType(nftId, expectedObjectType)++`]
* [`++_initializeNftOwnable(registry, initialOwner)++`]
* [`++linkToRegisteredNftId()++`]
* [`++getNftId()++`]
* [`++getOwner()++`]
* [`++_linkToNftOwnable(nftOwnableAddress)++`]

[.contract-subindex-inherited]
.INftOwnable

[.contract-subindex-inherited]
.RegistryLinked
* [`++_initializeRegistryLinked(registry)++`]
* [`++getRegistry()++`]

[.contract-subindex-inherited]
.IRegistryLinked

[.contract-subindex-inherited]
.InitializableERC165
* [`++_initializeERC165()++`]
* [`++_registerInterface(interfaceId)++`]
* [`++supportsInterface(interfaceId)++`]

[.contract-subindex-inherited]
.IERC165

[.contract-subindex-inherited]
.Initializable
* [`++_checkInitializing()++`]
* [`++_disableInitializers()++`]
* [`++_getInitializedVersion()++`]
* [`++_isInitializing()++`]

--

[.contract-index]
.Events
--

[.contract-subindex-inherited]
.INftOwnable

[.contract-subindex-inherited]
.RegistryLinked

[.contract-subindex-inherited]
.IRegistryLinked

[.contract-subindex-inherited]
.InitializableERC165

[.contract-subindex-inherited]
.IERC165

[.contract-subindex-inherited]
.Initializable
* [`++Initialized(version)++`]

--

[.contract-item]
[[NftOwnable-onlyOwner--]]
==== `[.contract-item-name]#++onlyOwner++#++()++` [.item-kind]#modifier#

enforces msg.sender is owner of nft (or initial owner of nft ownable)

[.contract-item]
[[NftOwnable-onlyNftOwner-NftId-]]
==== `[.contract-item-name]#++onlyNftOwner++#++(NftId nftId)++` [.item-kind]#modifier#

[.contract-item]
[[NftOwnable-onlyNftOfType-NftId-ObjectType-]]
==== `[.contract-item-name]#++onlyNftOfType++#++(NftId nftId, ObjectType expectedObjectType)++` [.item-kind]#modifier#

[.contract-item]
[[NftOwnable-_checkNftType-NftId-ObjectType-]]
==== `[.contract-item-name]#++_checkNftType++#++(NftId nftId, ObjectType expectedObjectType)++` [.item-kind]#internal#

[.contract-item]
[[NftOwnable-_initializeNftOwnable-address-address-]]
==== `[.contract-item-name]#++_initializeNftOwnable++#++(address registry, address initialOwner)++` [.item-kind]#internal#

initialization for upgradable contracts

[.contract-item]
[[NftOwnable-linkToRegisteredNftId--]]
==== `[.contract-item-name]#++linkToRegisteredNftId++#++() → NftId nftId++` [.item-kind]#public#

links this contract to nft after registration

[.contract-item]
[[NftOwnable-getNftId--]]
==== `[.contract-item-name]#++getNftId++#++() → NftId++` [.item-kind]#public#

[.contract-item]
[[NftOwnable-getOwner--]]
==== `[.contract-item-name]#++getOwner++#++() → address++` [.item-kind]#public#

[.contract-item]
[[NftOwnable-_linkToNftOwnable-address-]]
==== `[.contract-item-name]#++_linkToNftOwnable++#++(address nftOwnableAddress) → NftId++` [.item-kind]#internal#

used in constructor of registry service manager

:_initializePolicyHolder: pass:normal[xref:#PolicyHolder-_initializePolicyHolder-address-[`++_initializePolicyHolder++`]]
:policyActivated: pass:normal[xref:#PolicyHolder-policyActivated-NftId-Timestamp-[`++policyActivated++`]]
:policyExpired: pass:normal[xref:#PolicyHolder-policyExpired-NftId-Timestamp-[`++policyExpired++`]]
:claimConfirmed: pass:normal[xref:#PolicyHolder-claimConfirmed-NftId-ClaimId-Amount-[`++claimConfirmed++`]]
:payoutExecuted: pass:normal[xref:#PolicyHolder-payoutExecuted-NftId-PayoutId-Amount-address-[`++payoutExecuted++`]]
:onERC721Received: pass:normal[xref:#PolicyHolder-onERC721Received-address-address-uint256-bytes-[`++onERC721Received++`]]

[.contract]
[[PolicyHolder]]
=== `++PolicyHolder++` link:https://github.com/etherisc/gif-next/blob/develop/contracts/shared/PolicyHolder.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@etherisc/gif-next/contracts/shared/PolicyHolder.sol";
```

template implementation for IPolicyHolder

[.contract-index]
.Functions
--
* [`++_initializePolicyHolder(registryAddress)++`]
* [`++policyActivated(policyNftId, activatedAt)++`]
* [`++policyExpired(policyNftId, expiredAt)++`]
* [`++claimConfirmed(policyNftId, claimId, amount)++`]
* [`++payoutExecuted(policyNftId, payoutId, amount, beneficiary)++`]
* [`++onERC721Received(, , , )++`]

[.contract-subindex-inherited]
.IPolicyHolder

[.contract-subindex-inherited]
.RegistryLinked
* [`++_initializeRegistryLinked(registry)++`]
* [`++getRegistry()++`]

[.contract-subindex-inherited]
.IRegistryLinked

[.contract-subindex-inherited]
.IERC721Receiver

[.contract-subindex-inherited]
.InitializableERC165
* [`++_initializeERC165()++`]
* [`++_registerInterface(interfaceId)++`]
* [`++supportsInterface(interfaceId)++`]

[.contract-subindex-inherited]
.IERC165

[.contract-subindex-inherited]
.Initializable
* [`++_checkInitializing()++`]
* [`++_disableInitializers()++`]
* [`++_getInitializedVersion()++`]
* [`++_isInitializing()++`]

--

[.contract-index]
.Events
--

[.contract-subindex-inherited]
.IPolicyHolder

[.contract-subindex-inherited]
.RegistryLinked

[.contract-subindex-inherited]
.IRegistryLinked

[.contract-subindex-inherited]
.IERC721Receiver

[.contract-subindex-inherited]
.InitializableERC165

[.contract-subindex-inherited]
.IERC165

[.contract-subindex-inherited]
.Initializable
* [`++Initialized(version)++`]

--

[.contract-item]
[[PolicyHolder-_initializePolicyHolder-address-]]
==== `[.contract-item-name]#++_initializePolicyHolder++#++(address registryAddress)++` [.item-kind]#internal#

[.contract-item]
[[PolicyHolder-policyActivated-NftId-Timestamp-]]
==== `[.contract-item-name]#++policyActivated++#++(NftId policyNftId, Timestamp activatedAt)++` [.item-kind]#external#

empty default implementation

[.contract-item]
[[PolicyHolder-policyExpired-NftId-Timestamp-]]
==== `[.contract-item-name]#++policyExpired++#++(NftId policyNftId, Timestamp expiredAt)++` [.item-kind]#external#

empty default implementation

[.contract-item]
[[PolicyHolder-claimConfirmed-NftId-ClaimId-Amount-]]
==== `[.contract-item-name]#++claimConfirmed++#++(NftId policyNftId, ClaimId claimId, Amount amount)++` [.item-kind]#external#

empty default implementation

[.contract-item]
[[PolicyHolder-payoutExecuted-NftId-PayoutId-Amount-address-]]
==== `[.contract-item-name]#++payoutExecuted++#++(NftId policyNftId, PayoutId payoutId, Amount amount, address beneficiary)++` [.item-kind]#external#

empty default implementation

[.contract-item]
[[PolicyHolder-onERC721Received-address-address-uint256-bytes-]]
==== `[.contract-item-name]#++onERC721Received++#++(address, address, uint256, bytes) → bytes4++` [.item-kind]#external#

:GIF_RELEASE: pass:normal[xref:#Registerable-GIF_RELEASE-uint256[`++GIF_RELEASE++`]]
:REGISTERABLE_LOCATION_V1: pass:normal[xref:#Registerable-REGISTERABLE_LOCATION_V1-bytes32[`++REGISTERABLE_LOCATION_V1++`]]
:RegisterableStorage: pass:normal[xref:#Registerable-RegisterableStorage[`++RegisterableStorage++`]]
:_initializeRegisterable: pass:normal[xref:#Registerable-_initializeRegisterable-address-NftId-ObjectType-bool-address-bytes-[`++_initializeRegisterable++`]]
:getRelease: pass:normal[xref:#Registerable-getRelease--[`++getRelease++`]]
:getInitialInfo: pass:normal[xref:#Registerable-getInitialInfo--[`++getInitialInfo++`]]

[.contract]
[[Registerable]]
=== `++Registerable++` link:https://github.com/etherisc/gif-next/blob/develop/contracts/shared/Registerable.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@etherisc/gif-next/contracts/shared/Registerable.sol";
```

[.contract-index]
.Functions
--
* [`++_initializeRegisterable(registry, parentNftId, objectType, isInterceptor, initialOwner, data)++`]
* [`++getRelease()++`]
* [`++getInitialInfo()++`]

[.contract-subindex-inherited]
.IRegisterable

[.contract-subindex-inherited]
.NftOwnable
* [`++_checkNftType(nftId, expectedObjectType)++`]
* [`++_initializeNftOwnable(registry, initialOwner)++`]
* [`++linkToRegisteredNftId()++`]
* [`++getNftId()++`]
* [`++getOwner()++`]
* [`++_linkToNftOwnable(nftOwnableAddress)++`]

[.contract-subindex-inherited]
.INftOwnable

[.contract-subindex-inherited]
.RegistryLinked
* [`++_initializeRegistryLinked(registry)++`]
* [`++getRegistry()++`]

[.contract-subindex-inherited]
.IRegistryLinked

[.contract-subindex-inherited]
.InitializableERC165
* [`++_initializeERC165()++`]
* [`++_registerInterface(interfaceId)++`]
* [`++supportsInterface(interfaceId)++`]

[.contract-subindex-inherited]
.IERC165

[.contract-subindex-inherited]
.Initializable
* [`++_checkInitializing()++`]
* [`++_disableInitializers()++`]
* [`++_getInitializedVersion()++`]
* [`++_isInitializing()++`]

--

[.contract-index]
.Events
--

[.contract-subindex-inherited]
.IRegisterable

[.contract-subindex-inherited]
.NftOwnable

[.contract-subindex-inherited]
.INftOwnable

[.contract-subindex-inherited]
.RegistryLinked

[.contract-subindex-inherited]
.IRegistryLinked

[.contract-subindex-inherited]
.InitializableERC165

[.contract-subindex-inherited]
.IERC165

[.contract-subindex-inherited]
.Initializable
* [`++Initialized(version)++`]

--

[.contract-item]
[[Registerable-_initializeRegisterable-address-NftId-ObjectType-bool-address-bytes-]]
==== `[.contract-item-name]#++_initializeRegisterable++#++(address registry, NftId parentNftId, ObjectType objectType, bool isInterceptor, address initialOwner, bytes data)++` [.item-kind]#internal#

[.contract-item]
[[Registerable-getRelease--]]
==== `[.contract-item-name]#++getRelease++#++() → VersionPart release++` [.item-kind]#public#

retuns the GIF release version for this contract.
This

[.contract-item]
[[Registerable-getInitialInfo--]]
==== `[.contract-item-name]#++getInitialInfo++#++() → struct IRegistry.ObjectInfo info++` [.item-kind]#public#

retuns the object info relevant for registering for this contract 
IMPORTANT information returned by this function may only be used
before the contract is registered in the registry.
Once registered this information MUST only be accessed via the registry.

:_initializeRegistryLinked: pass:normal[xref:#RegistryLinked-_initializeRegistryLinked-address-[`++_initializeRegistryLinked++`]]
:getRegistry: pass:normal[xref:#RegistryLinked-getRegistry--[`++getRegistry++`]]

[.contract]
[[RegistryLinked]]
=== `++RegistryLinked++` link:https://github.com/etherisc/gif-next/blob/develop/contracts/shared/RegistryLinked.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@etherisc/gif-next/contracts/shared/RegistryLinked.sol";
```

[.contract-index]
.Functions
--
* [`++_initializeRegistryLinked(registry)++`]
* [`++getRegistry()++`]

[.contract-subindex-inherited]
.IRegistryLinked

[.contract-subindex-inherited]
.Initializable
* [`++_checkInitializing()++`]
* [`++_disableInitializers()++`]
* [`++_getInitializedVersion()++`]
* [`++_isInitializing()++`]

--

[.contract-index]
.Events
--

[.contract-subindex-inherited]
.IRegistryLinked

[.contract-subindex-inherited]
.Initializable
* [`++Initialized(version)++`]

--

[.contract-item]
[[RegistryLinked-_initializeRegistryLinked-address-]]
==== `[.contract-item-name]#++_initializeRegistryLinked++#++(address registry)++` [.item-kind]#internal#

initialization for upgradable contracts

[.contract-item]
[[RegistryLinked-getRegistry--]]
==== `[.contract-item-name]#++getRegistry++#++() → contract IRegistry++` [.item-kind]#public#

:_initializeService: pass:normal[xref:#Service-_initializeService-address-address-address-[`++_initializeService++`]]
:getDomain: pass:normal[xref:#Service-getDomain--[`++getDomain++`]]
:getRoleId: pass:normal[xref:#Service-getRoleId--[`++getRoleId++`]]
:getVersion: pass:normal[xref:#Service-getVersion--[`++getVersion++`]]
:_getDomain: pass:normal[xref:#Service-_getDomain--[`++_getDomain++`]]
:_getServiceAddress: pass:normal[xref:#Service-_getServiceAddress-ObjectType-[`++_getServiceAddress++`]]

[.contract]
[[Service]]
=== `++Service++` link:https://github.com/etherisc/gif-next/blob/develop/contracts/shared/Service.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@etherisc/gif-next/contracts/shared/Service.sol";
```

service base contract

[.contract-index]
.Functions
--
* [`++_initializeService(registry, authority, initialOwner)++`]
* [`++getDomain()++`]
* [`++getRoleId()++`]
* [`++getVersion()++`]
* [`++_getDomain()++`]
* [`++_getServiceAddress(domain)++`]

[.contract-subindex-inherited]
.IService

[.contract-subindex-inherited]
.ReentrancyGuardUpgradeable
* [`++__ReentrancyGuard_init()++`]
* [`++__ReentrancyGuard_init_unchained()++`]
* [`++_reentrancyGuardEntered()++`]

[.contract-subindex-inherited]
.AccessManagedUpgradeable
* [`++__AccessManaged_init(initialAuthority)++`]
* [`++__AccessManaged_init_unchained(initialAuthority)++`]
* [`++authority()++`]
* [`++setAuthority(newAuthority)++`]
* [`++isConsumingScheduledOp()++`]
* [`++_setAuthority(newAuthority)++`]
* [`++_checkCanCall(caller, data)++`]

[.contract-subindex-inherited]
.Versionable
* [`++initializeVersionable(activatedBy, data)++`]
* [`++upgradeVersionable(data)++`]
* [`++_initialize(owner, data)++`]
* [`++_upgrade(data)++`]

[.contract-subindex-inherited]
.Registerable
* [`++_initializeRegisterable(registry, parentNftId, objectType, isInterceptor, initialOwner, data)++`]
* [`++getRelease()++`]
* [`++getInitialInfo()++`]

[.contract-subindex-inherited]
.IRegisterable

[.contract-subindex-inherited]
.NftOwnable
* [`++_checkNftType(nftId, expectedObjectType)++`]
* [`++_initializeNftOwnable(registry, initialOwner)++`]
* [`++linkToRegisteredNftId()++`]
* [`++getNftId()++`]
* [`++getOwner()++`]
* [`++_linkToNftOwnable(nftOwnableAddress)++`]

[.contract-subindex-inherited]
.INftOwnable

[.contract-subindex-inherited]
.RegistryLinked
* [`++_initializeRegistryLinked(registry)++`]
* [`++getRegistry()++`]

[.contract-subindex-inherited]
.IRegistryLinked

[.contract-subindex-inherited]
.InitializableERC165
* [`++_initializeERC165()++`]
* [`++_registerInterface(interfaceId)++`]
* [`++supportsInterface(interfaceId)++`]

[.contract-subindex-inherited]
.IERC165

[.contract-subindex-inherited]
.IAccessManaged

[.contract-subindex-inherited]
.IVersionable

[.contract-subindex-inherited]
.ContextUpgradeable
* [`++__Context_init()++`]
* [`++__Context_init_unchained()++`]
* [`++_msgSender()++`]
* [`++_msgData()++`]
* [`++_contextSuffixLength()++`]

[.contract-subindex-inherited]
.Initializable
* [`++_checkInitializing()++`]
* [`++_disableInitializers()++`]
* [`++_getInitializedVersion()++`]
* [`++_isInitializing()++`]

--

[.contract-index]
.Events
--

[.contract-subindex-inherited]
.IService

[.contract-subindex-inherited]
.ReentrancyGuardUpgradeable

[.contract-subindex-inherited]
.AccessManagedUpgradeable

[.contract-subindex-inherited]
.Versionable

[.contract-subindex-inherited]
.Registerable

[.contract-subindex-inherited]
.IRegisterable

[.contract-subindex-inherited]
.NftOwnable

[.contract-subindex-inherited]
.INftOwnable

[.contract-subindex-inherited]
.RegistryLinked

[.contract-subindex-inherited]
.IRegistryLinked

[.contract-subindex-inherited]
.InitializableERC165

[.contract-subindex-inherited]
.IERC165

[.contract-subindex-inherited]
.IAccessManaged
* [`++AuthorityUpdated(authority)++`]

[.contract-subindex-inherited]
.IVersionable

[.contract-subindex-inherited]
.ContextUpgradeable

[.contract-subindex-inherited]
.Initializable
* [`++Initialized(version)++`]

--

[.contract-item]
[[Service-_initializeService-address-address-address-]]
==== `[.contract-item-name]#++_initializeService++#++(address registry, address authority, address initialOwner)++` [.item-kind]#internal#

[.contract-item]
[[Service-getDomain--]]
==== `[.contract-item-name]#++getDomain++#++() → ObjectType serviceDomain++` [.item-kind]#external#

returns the domain for this service.
In any GIF release only one service for any given domain may be deployed.

[.contract-item]
[[Service-getRoleId--]]
==== `[.contract-item-name]#++getRoleId++#++() → RoleId serviceRoleId++` [.item-kind]#external#

returns the GIF release specific role id.
These role ids are used to authorize service to service communication.

[.contract-item]
[[Service-getVersion--]]
==== `[.contract-item-name]#++getVersion++#++() → Version++` [.item-kind]#public#

returns version of this contract
each new implementation MUST implement this function
version number MUST increase

[.contract-item]
[[Service-_getDomain--]]
==== `[.contract-item-name]#++_getDomain++#++() → ObjectType++` [.item-kind]#internal#

[.contract-item]
[[Service-_getServiceAddress-ObjectType-]]
==== `[.contract-item-name]#++_getServiceAddress++#++(ObjectType domain) → address++` [.item-kind]#internal#

:ErrorTokenHandlerNotService: pass:normal[xref:#TokenHandler-ErrorTokenHandlerNotService-address-[`++ErrorTokenHandlerNotService++`]]
:ErrorTokenHandlerRecipientWalletsMustBeDistinct: pass:normal[xref:#TokenHandler-ErrorTokenHandlerRecipientWalletsMustBeDistinct-address-address-address-[`++ErrorTokenHandlerRecipientWalletsMustBeDistinct++`]]
:onlyService: pass:normal[xref:#TokenHandler-onlyService--[`++onlyService++`]]
:constructor: pass:normal[xref:#TokenHandler-constructor-address-address-address-address-[`++constructor++`]]
:setWallet: pass:normal[xref:#TokenHandler-setWallet-address-[`++setWallet++`]]
:approve: pass:normal[xref:#TokenHandler-approve-contract-IERC20Metadata-Amount-[`++approve++`]]
:collectTokens: pass:normal[xref:#TokenHandler-collectTokens-address-Amount-[`++collectTokens++`]]
:pushToken: pass:normal[xref:#TokenHandler-pushToken-address-Amount-[`++pushToken++`]]
:collectTokensToThreeRecipients: pass:normal[xref:#TokenHandler-collectTokensToThreeRecipients-address-address-Amount-address-Amount-address-Amount-[`++collectTokensToThreeRecipients++`]]
:distributeTokens: pass:normal[xref:#TokenHandler-distributeTokens-address-address-Amount-[`++distributeTokens++`]]

[.contract]
[[TokenHandler]]
=== `++TokenHandler++` link:https://github.com/etherisc/gif-next/blob/develop/contracts/shared/TokenHandler.sol[{github-icon},role=heading-link]

[.hljs-theme-light.nopadding]
```solidity
import "@etherisc/gif-next/contracts/shared/TokenHandler.sol";
```

Token specific transfer helper
a default token contract is provided via contract constructor
relies internally on oz SafeERC20.safeTransferFrom

[.contract-index]
.Modifiers
--
* {xref-TokenHandler-onlyService--}[`++onlyService()++`]
--

[.contract-index]
.Functions
--
* [`++constructor(registry, component, token, authority)++`]
* [`++setWallet(newWallet)++`]
* [`++approve(token, amount)++`]
* [`++collectTokens(from, amount)++`]
* [`++pushToken(from, amount)++`]
* [`++collectTokensToThreeRecipients(from, to, amount, to2, amount2, to3, amount3)++`]
* [`++distributeTokens(from, to, amount)++`]

[.contract-subindex-inherited]
.TokenHandlerBase
* [`++getWallet()++`]
* [`++_approve(token, amount)++`]
* [`++_setWallet(newWallet)++`]
* [`++_pullAndPushToken(from, pullAmount, to1, amount1, to2, amount2)++`]
* [`++_pullToken(from, amount)++`]
* [`++_pushToken(to, amount)++`]
* [`++_transfer(from, to, amount, checkPreconditions)++`]
* [`++_checkPreconditions(from, amount)++`]

[.contract-subindex-inherited]
.AccessManaged
* [`++authority()++`]
* [`++setAuthority(newAuthority)++`]
* [`++isConsumingScheduledOp()++`]
* [`++_setAuthority(newAuthority)++`]
* [`++_checkCanCall(caller, data)++`]

[.contract-subindex-inherited]
.IAccessManaged

--

[.contract-index]
.Events
--

[.contract-subindex-inherited]
.TokenHandlerBase
* [`++LogTokenHandlerWalletAddressChanged(componentNftId, oldWallet, newWallet)++`]
* [`++LogTokenHandlerWalletTokensTransferred(componentNftId, oldWallet, newWallet, amount)++`]
* [`++LogTokenHandlerTokenApproved(nftId, tokenHandler, token, amount, isMaxAmount)++`]
* [`++LogTokenHandlerTokenTransfer(token, from, to, amount)++`]

[.contract-subindex-inherited]
.AccessManaged

[.contract-subindex-inherited]
.IAccessManaged
* [`++AuthorityUpdated(authority)++`]

--

[.contract-item]
[[TokenHandler-onlyService--]]
==== `[.contract-item-name]#++onlyService++#++()++` [.item-kind]#modifier#

[.contract-item]
[[TokenHandler-constructor-address-address-address-address-]]
==== `[.contract-item-name]#++constructor++#++(address registry, address component, address token, address authority)++` [.item-kind]#public#

[.contract-item]
[[TokenHandler-setWallet-address-]]
==== `[.contract-item-name]#++setWallet++#++(address newWallet)++` [.item-kind]#external#

sets the wallet address for the component.
if the current wallet has tokens, these will be transferred.
if the new wallet address is externally owned, an approval from the 
owner of the external wallet to the tokenhandler of the component that 
covers the current component balance must exist

[.contract-item]
[[TokenHandler-approve-contract-IERC20Metadata-Amount-]]
==== `[.contract-item-name]#++approve++#++(contract IERC20Metadata token, Amount amount)++` [.item-kind]#external#

Approves token handler to spend up to the specified amount of tokens.
Sets spending limit to type(uint256).max for AmountLib.max().
Reverts if component wallet is not component itself.
Sets approvel using SareERC20.forceApprove internally.

[.contract-item]
[[TokenHandler-collectTokens-address-Amount-]]
==== `[.contract-item-name]#++collectTokens++#++(address from, Amount amount)++` [.item-kind]#external#

Collect tokens from outside of GIF and transfer them to the wallet.
This method also checks balance and allowance and makes sure the amount is greater than zero.

[.contract-item]
[[TokenHandler-pushToken-address-Amount-]]
==== `[.contract-item-name]#++pushToken++#++(address from, Amount amount)++` [.item-kind]#external#

Collect tokens from outside of GIF and transfer them to the wallet.
This method also checks balance and allowance and makes sure the amount is greater than zero.

[.contract-item]
[[TokenHandler-collectTokensToThreeRecipients-address-address-Amount-address-Amount-address-Amount-]]
==== `[.contract-item-name]#++collectTokensToThreeRecipients++#++(address from, address to, Amount amount, address to2, Amount amount2, address to3, Amount amount3)++` [.item-kind]#external#

collect tokens from outside of the gif and transfer them to three distinct wallets within the scope of gif
This method also checks balance and allowance and makes sure the amount is greater than zero.

[.contract-item]
[[TokenHandler-distributeTokens-address-address-Amount-]]
==== `[.contract-item-name]#++distributeTokens++#++(address from, address to, Amount amount)++` [.item-kind]#external#

distribute tokens from a wallet within the scope of gif to an external address.
This method also checks balance and allowance and makes sure the amount is greater than zero.

