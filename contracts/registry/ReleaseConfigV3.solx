// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.20;

import {AccessManaged} from "@openzeppelin/contracts/access/manager/AccessManaged.sol";

import {NftId} from "../types/NftId.sol";
import {RoleId} from "../types/RoleId.sol";
import {ObjectType, ObjectTypeLib, zeroObjectType, REGISTRY, SERVICE} from "../types/ObjectType.sol";
import {VersionPart, VersionPartLib} from "../types/Version.sol";
import {Timestamp, TimestampLib} from "../types/Timestamp.sol";

import {IService} from "../shared/IService.sol";

import {IRegistry} from "./IRegistry.sol";
import {Registry} from "./Registry.sol";
import {IRegistryService} from "./IRegistryService.sol";
import {RegistryAccessManager} from "./RegistryAccessManager.sol";


contract ReleaseConfigV3 is IReleaseConfig
{
    // USED BY REGISTRY ACCESS MANAGER

    // domain-function set to connect services to registry service
    function getFunctionConfigs()
        external
        pure
        returns(
            FunctionConfig[] memory config
        )
    {
        config = new FunctionConfig[](8);

        // order of service registrations MUST be reverse to this array 
        /*config[-1].serviceDomain = STAKE();
        config[-1].selector = RegistryService.registerStake.selector;*/

        config[0].serviceDomain = POLICY();
        config[0].selectors = new bytes4[](0);

        config[1].serviceDomain = APPLICATION();
        config[1].selectors = new bytes4[](1);
        config[1].selectors[0] = RegistryService.registerPolicy.selector;

        config[2].serviceDomain = CLAIM();
        config[2].selectors = new bytes4[](0);

        config[3].serviceDomain = BUNDLE();
        config[3].selectors = new bytes4[](1);
        config[3].selectors[0] = RegistryService.registerBundle.selector;

        config[4].serviceDomain = PRODUCT();
        config[4].selectors = new bytes4[](1);
        config[4].selectors[0] = RegistryService.registerProduct.selector;

        config[5].serviceDomain = POOL();
        config[5].selectors = new bytes4[](1);
        config[5].selectors[0] = RegistryService.registerPool.selector;

        config[6].serviceDomain = DISTRIBUTION();
        config[6].selectors = new bytes4[](2);
        config[6].selectors[0] = RegistryService.registerDistribution.selector;
        config[6].selectors[1] = RegistryService.registerDistributor.selector;

        // registerInstance() have no restriction
        config[7].serviceDomain = INSTANCE();
        config[7].selectors = new bytes4[](1);
        config[7].selectors[0] = RegistryService.registerInstance.selector;
    }

    // USED BY RELESASE ACCESS MANAGER

    // set of all roles in release

    // role-function set for each service in release

    // precalculated address of each service in release
    // 1. upon service registration its authority is checked
    // service must know release access manager at initialization time
    // release access manager is created during createNextRelease() where precalculated addresses of all services also must be known 
    // 1. precalculate next release access manager address
    // 2. precalculate addresses of all service with 1).
    // 3. call createNextRelease() giving all addresses 2)
    //       release access manager get deployed to address 1).
    // 4. each service get deployed and registered

}
